/* This file has been autogenerated by Ivory
 * Compiler version  0.1.0.0
 */
#include "control_pid.h"

float fconstrain(float n_var0, float n_var1, float n_var2)
{
    if (n_var2 < n_var0) {
        return n_var0;
    } else {
        if (n_var2 > n_var1) {
            return n_var1;
        } else {
            return n_var2;
        }
    }
}

float pid_update(struct PIDState* n_var0, const struct PIDConfig* n_var1,
                 float n_var2, float n_var3)
{
    REQUIRES(!(bool) isnan(n_var2) && !(bool) isinf(n_var2));
    REQUIRES(!(bool) isnan(n_var3) && !(bool) isinf(n_var3));
    
    float n_deref0 = n_var1->pid_pGain;
    float n_deref1 = n_var1->pid_iMin;
    float n_deref2 = n_var1->pid_iMax;
    float n_deref3 = n_var0->pid_iState;
    float n_r4 = fconstrain(n_deref1, n_deref2, n_deref3 + n_var2);
    
    *&n_var0->pid_iState = n_r4;
    
    float n_deref5 = n_var1->pid_iGain;
    float n_deref6 = n_var0->pid_iState;
    uint8_t n_deref7 = n_var0->pid_reset;
    float n_local8 = 0.0f;
    float* n_ref9 = &n_local8;
    
    if (n_deref7 != 0U) {
        *&n_var0->pid_reset = 0U;
    } else {
        float n_deref10 = n_var0->pid_dState;
        float n_deref11 = n_var1->pid_dGain;
        
        *n_ref9 = n_deref11 * (n_var3 - n_deref10);
    }
    *&n_var0->pid_dState = n_var3;
    
    float n_deref12 = *n_ref9;
    
    return n_deref0 * n_var2 + n_deref5 * n_deref6 - n_deref12;
}