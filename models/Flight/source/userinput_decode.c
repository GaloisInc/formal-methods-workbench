/* This file has been autogenerated by Ivory
 * Compiler version  0.1.0.0
 */
#include "userinput_decode.h"

static float userinput_scale(uint16_t n_var0, uint16_t n_var1, float n_var2,
                             float n_var3, uint16_t n_var4);

void userinput_decode(uint16_t n_var0[8U], struct userinput_result* n_var1,
                      uint32_t n_var2)
{
    uint16_t n_deref0 = n_var0[0];
    float n_r1 = userinput_scale(1500U, 500U, -1.0f, 1.0f, n_deref0);
    
    *&n_var1->roll = n_r1;
    
    uint16_t n_deref2 = n_var0[1];
    float n_r3 = userinput_scale(1500U, 500U, -1.0f, 1.0f, n_deref2);
    
    *&n_var1->pitch = n_r3;
    
    uint16_t n_deref4 = n_var0[2];
    float n_r5 = userinput_scale(1500U, 500U, -1.0f, 1.0f, n_deref4);
    
    *&n_var1->throttle = n_r5;
    
    uint16_t n_deref6 = n_var0[3];
    float n_r7 = userinput_scale(1500U, 500U, -1.0f, 1.0f, n_deref6);
    
    *&n_var1->yaw = n_r7;
    *&n_var1->time = n_var2;
    return;
}

void userinput_failsafe(struct userinput_result* n_var0, uint32_t n_var1)
{
    {
        uint32_t n_pre0 = n_var0->time;
        
        REQUIRES(n_var1 >= n_pre0);
    }
    
    uint32_t n_deref1 = n_var0->time;
    
    ASSERTS(n_var1 >= n_deref1);
    if (n_var1 - n_deref1 > 150U) {
        *&n_var0->throttle = 0.0f;
        *&n_var0->yaw = 0.0f;
        *&n_var0->pitch = 0.0f;
        *&n_var0->roll = 0.0f;
    }
    return;
}

void set_flight_mode(uint16_t n_var0[8U], struct flightmode_state* n_var1,
                     struct arming_state* n_var2, struct flightmode* n_var3,
                     uint32_t n_var4)
{
    {
        uint32_t n_pre0 = n_var2->arm_state_time;
        
        REQUIRES(n_var4 >= n_pre0);
    }
    
    uint16_t n_deref1 = n_var0[4];
    uint16_t n_deref2 = n_var1->last_modepwm;
    uint32_t n_deref3 = n_var1->last_modepwm_time;
    
    ASSERTS((int32_t) n_deref1 > 0 && ((int32_t) n_deref2 < 0 && 2147483647 -
                                       (int32_t) n_deref1 +
                                       (int32_t) n_deref2 >= 0) ||
        ((int32_t) n_deref2 > 0 && ((int32_t) n_deref1 < 0 && 2147483647 -
                                    (int32_t) n_deref2 + (int32_t) n_deref1 >=
                                    0) || ((int32_t) n_deref1 >= 0 &&
                                           (int32_t) n_deref2 >= 0 ||
                                           (int32_t) n_deref1 <= 0 &&
                                           (int32_t) n_deref2 <= 0)));
    ASSERTS((int32_t) n_deref1 > 0 && ((int32_t) n_deref2 < 0 && 2147483647 -
                                       (int32_t) n_deref1 +
                                       (int32_t) n_deref2 >= 0) ||
        ((int32_t) n_deref2 > 0 && ((int32_t) n_deref1 < 0 && 2147483647 -
                                    (int32_t) n_deref2 + (int32_t) n_deref1 >=
                                    0) || ((int32_t) n_deref1 >= 0 &&
                                           (int32_t) n_deref2 >= 0 ||
                                           (int32_t) n_deref1 <= 0 &&
                                           (int32_t) n_deref2 <= 0)));
    ASSERTS(!(abs_i32((int32_t) n_deref1 - (int32_t) n_deref2) <= 65535 &&
              abs_i32((int32_t) n_deref1 - (int32_t) n_deref2) >= 0) ||
        ((int32_t) n_deref1 > 0 && ((int32_t) n_deref2 < 0 && 2147483647 -
                                    (int32_t) n_deref1 + (int32_t) n_deref2 >=
                                    0) || ((int32_t) n_deref2 > 0 &&
                                           ((int32_t) n_deref1 < 0 &&
                                            2147483647 - (int32_t) n_deref2 +
                                            (int32_t) n_deref1 >= 0) ||
                                           ((int32_t) n_deref1 >= 0 &&
                                            (int32_t) n_deref2 >= 0 ||
                                            (int32_t) n_deref1 <= 0 &&
                                            (int32_t) n_deref2 <= 0))));
    if ((abs_i32((int32_t) n_deref1 - (int32_t) n_deref2) <= 65535 &&
         abs_i32((int32_t) n_deref1 - (int32_t) n_deref2) >=
         0 ? (uint16_t) abs_i32((int32_t) n_deref1 - (int32_t) n_deref2) : 0U) >
        10U) {
        ASSERTS(n_var4 >= n_deref3);
        if (n_var4 - n_deref3 > 250U) {
            *&n_var1->last_modepwm = n_deref1;
            *&n_var1->last_modepwm_time = n_var4;
            *&n_var1->valid_modepwm = n_deref1;
        }
    } else {
        *&n_var1->last_modepwm = n_deref1;
        *&n_var1->last_modepwm_time = n_var4;
    }
    
    uint16_t n_deref4 = n_var1->valid_modepwm;
    
    *&n_var3->mode = n_deref4 >= 900U && n_deref4 <= 1300U ? 2U : n_deref4 >=
        1301U && n_deref4 <= 1700U ? 1U : n_deref4 >= 1701U && n_deref4 <=
        2100U ? 0U : 0U;
    *&n_var3->time = n_var4;
    return;
}

bool deadManSwitch(const uint16_t n_var0[8U])
{
    uint16_t n_deref0 = n_var0[5];
    
    return n_deref0 >= 1500U;
}

bool armingStatemachine(uint16_t n_var0[8U], struct arming_state* n_var1,
                        uint8_t* n_var2, uint32_t n_var3)
{
    uint16_t n_deref0 = n_var0[2];
    uint16_t n_deref1 = n_var0[3];
    bool n_r2 = deadManSwitch(n_var0);
    
    if (!n_r2 || !(n_deref0 < 1050U && n_deref1 > 1900U)) {
        *&n_var1->arm_state = 0U;
        *&n_var1->arm_state_time = n_var3;
        return false;
    }
    
    uint8_t n_deref3 = n_var1->arm_state;
    
    if (n_deref3 == 0U) {
        *&n_var1->arm_state_time = n_var3;
        *&n_var1->arm_state = 1U;
    } else {
        if (n_deref3 == 1U) {
            uint32_t n_deref4 = n_var1->arm_state_time;
            
            ASSERTS(n_var3 >= n_deref4);
            if (n_var3 - n_deref4 > 500U) {
                *&n_var1->arm_state = 2U;
                *n_var2 = 1U;
                return true;
            }
        }
    }
    return false;
}

float userinput_scale(uint16_t n_var0, uint16_t n_var1, float n_var2,
                      float n_var3, uint16_t n_var4)
{
    REQUIRES(n_var1 != 0U && (n_var4 >= 900U && n_var4 <= 2100U));
    ASSERTS((float) n_var1 != 0.0f);
    if (((float) n_var4 - (float) n_var0) / (float) n_var1 < n_var2) {
        return n_var2;
    } else {
        ASSERTS((float) n_var1 != 0.0f);
        if (((float) n_var4 - (float) n_var0) / (float) n_var1 > n_var3) {
            return n_var3;
        } else {
            ASSERTS((float) n_var1 != 0.0f);
            return ((float) n_var4 - (float) n_var0) / (float) n_var1;
        }
    }
}