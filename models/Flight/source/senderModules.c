/* This file has been autogenerated by Ivory
 * Compiler version  0.1.0.0
 */
#include "senderModules.h"

void gcs_transmit_send_data16(struct data_rate_state* n_var0, uint8_t* n_var1,
                              uint8_t n_var2[80U])
{
    struct data16_msg n_local0 = {};
    struct data16_msg* n_ref1 = &n_local0;
    uint32_t n_deref2 = n_var0->dropped;
    uint32_t n_deref3 = n_var0->lastSucc;
    
    *&n_ref1->len = 8U;
    *&n_ref1->data16[0] = (uint8_t) ((uint16_t) (n_deref2 & 65535U) & 255U);
    *&n_ref1->data16[1] = (uint8_t) ((uint16_t) (n_deref2 >> 8U & 65535U) &
                                     255U);
    *&n_ref1->data16[2] = (uint8_t) ((uint16_t) (n_deref2 >> 8U >> 8U &
                                                 65535U) & 255U);
    *&n_ref1->data16[3] = (uint8_t) ((uint16_t) (n_deref2 >> 8U >> 8U >> 8U &
                                                 65535U) & 255U);
    *&n_ref1->data16[4] = (uint8_t) ((uint16_t) (n_deref3 & 65535U) & 255U);
    *&n_ref1->data16[5] = (uint8_t) ((uint16_t) (n_deref3 >> 8U & 65535U) &
                                     255U);
    *&n_ref1->data16[6] = (uint8_t) ((uint16_t) (n_deref3 >> 8U >> 8U &
                                                 65535U) & 255U);
    *&n_ref1->data16[7] = (uint8_t) ((uint16_t) (n_deref3 >> 8U >> 8U >> 8U &
                                                 65535U) & 255U);
    mavlink_data16_msg_send(n_ref1, n_var1, n_var2);
    return;
}

void gcs_transmit_send_heartbeat(struct flightmode* n_var0, bool* n_var1,
                                 uint8_t* n_var2, uint8_t n_var3[80U])
{
    struct heartbeat_msg n_local0 = {};
    struct heartbeat_msg* n_ref1 = &n_local0;
    bool n_deref2 = *n_var1;
    uint8_t n_deref3 = n_var0->mode;
    
    *&n_ref1->custom_mode = (uint32_t) n_deref3;
    *&n_ref1->mavtype = 2U;
    *&n_ref1->autopilot = 13U;
    if (n_deref2) {
        *&n_ref1->base_mode = 129U;
    } else {
        *&n_ref1->base_mode = 1U;
    }
    *&n_ref1->mavlink_version = 3U;
    mavlink_heartbeat_msg_send(n_ref1, n_var2, n_var3);
    return;
}

void gcs_transmit_send_attitude(struct sensors_result* n_var0, uint8_t* n_var1,
                                uint8_t n_var2[80U])
{
    struct attitude_msg n_local0 = {};
    struct attitude_msg* n_ref1 = &n_local0;
    uint32_t n_deref2 = n_var0->time;
    
    *&n_ref1->time_boot_ms = n_deref2;
    
    float n_deref3 = n_var0->roll;
    
    *&n_ref1->roll = n_deref3;
    
    float n_deref4 = n_var0->pitch;
    
    *&n_ref1->pitch = n_deref4;
    
    float n_deref5 = n_var0->yaw;
    
    *&n_ref1->yaw = n_deref5;
    
    float n_deref6 = n_var0->omega_x;
    
    *&n_ref1->rollspeed = n_deref6;
    
    float n_deref7 = n_var0->omega_y;
    
    *&n_ref1->pitchspeed = n_deref7;
    
    float n_deref8 = n_var0->omega_z;
    
    *&n_ref1->yawspeed = n_deref8;
    mavlink_attitude_msg_send(n_ref1, n_var1, n_var2);
    return;
}

void gcs_transmit_send_vfrhud(struct position* n_var0,
                              struct controloutput* n_var1,
                              struct sensors_result* n_var2, uint8_t* n_var3,
                              uint8_t n_var4[80U])
{
    struct vfr_hud_msg n_local0 = {};
    struct vfr_hud_msg* n_ref1 = &n_local0;
    uint32_t n_deref2 = n_var0->vground;
    
    *&n_ref1->groundspeed = (float) n_deref2 / 100.0f;
    
    uint32_t n_deref3 = n_var0->vground;
    
    *&n_ref1->airspeed = (float) n_deref3 / 100.0f;
    
    int32_t n_deref4 = n_var0->alt;
    float n_let5 = (float) n_deref4;
    
    *&n_ref1->alt = n_let5 / 1000.0f;
    
    int32_t n_deref6 = n_var0->vdown;
    
    *&n_ref1->climb = -(1.0f * ((float) n_deref6 / 100.0f));
    
    float n_deref7 = n_var2->yaw;
    float n_let8 = 180.0f / 3.1415927f * n_deref7;
    int16_t n_let9 = !(bool) isnan(n_let8) && (n_let8 <= 32767.0F && n_let8 >=
                                               -32768.0F) ? (int16_t) n_let8 : 0;
    
    *&n_ref1->heading = n_let9;
    
    float n_deref10 = n_var1->throttle;
    
    *&n_ref1->throttle = !(bool) isnan(n_deref10 * 100.0f) && (n_deref10 *
                                                               100.0f <=
                                                               65535.0F &&
                                                               n_deref10 *
                                                               100.0f >=
                                                               0.0F) ? (uint16_t) (n_deref10 *
                                                                                   100.0f) : 0U;
    mavlink_vfr_hud_msg_send(n_ref1, n_var3, n_var4);
    return;
}

void gcs_transmit_send_servo_output(struct motors* n_var0,
                                    struct controloutput* n_var1,
                                    uint8_t* n_var2, uint8_t n_var3[80U])
{
    struct servo_output_raw_msg n_local0 = {};
    struct servo_output_raw_msg* n_ref1 = &n_local0;
    float n_deref2 = n_var0->frontright;
    
    *&n_ref1->servo1_raw = !(bool) isnan(n_deref2 * 800.0f + 1100.0f) &&
        (n_deref2 * 800.0f + 1100.0f <= 65535.0F && n_deref2 * 800.0f +
         1100.0f >= 0.0F) ? (uint16_t) (n_deref2 * 800.0f + 1100.0f) : 0U;
    
    float n_deref3 = n_var0->backleft;
    
    *&n_ref1->servo2_raw = !(bool) isnan(n_deref3 * 800.0f + 1100.0f) &&
        (n_deref3 * 800.0f + 1100.0f <= 65535.0F && n_deref3 * 800.0f +
         1100.0f >= 0.0F) ? (uint16_t) (n_deref3 * 800.0f + 1100.0f) : 0U;
    
    float n_deref4 = n_var0->frontleft;
    
    *&n_ref1->servo3_raw = !(bool) isnan(n_deref4 * 800.0f + 1100.0f) &&
        (n_deref4 * 800.0f + 1100.0f <= 65535.0F && n_deref4 * 800.0f +
         1100.0f >= 0.0F) ? (uint16_t) (n_deref4 * 800.0f + 1100.0f) : 0U;
    
    float n_deref5 = n_var0->backright;
    
    *&n_ref1->servo4_raw = !(bool) isnan(n_deref5 * 800.0f + 1100.0f) &&
        (n_deref5 * 800.0f + 1100.0f <= 65535.0F && n_deref5 * 800.0f +
         1100.0f >= 0.0F) ? (uint16_t) (n_deref5 * 800.0f + 1100.0f) : 0U;
    
    float n_deref6 = n_var1->yaw;
    
    *&n_ref1->servo5_raw = !(bool) isnan(n_deref6 * 100.0f + 100.0f) &&
        (n_deref6 * 100.0f + 100.0f <= 65535.0F && n_deref6 * 100.0f + 100.0f >=
         0.0F) ? (uint16_t) (n_deref6 * 100.0f + 100.0f) : 9999U;
    
    float n_deref7 = n_var1->pitch;
    
    *&n_ref1->servo6_raw = !(bool) isnan(n_deref7 * 100.0f + 100.0f) &&
        (n_deref7 * 100.0f + 100.0f <= 65535.0F && n_deref7 * 100.0f + 100.0f >=
         0.0F) ? (uint16_t) (n_deref7 * 100.0f + 100.0f) : 9999U;
    
    float n_deref8 = n_var1->roll;
    
    *&n_ref1->servo7_raw = !(bool) isnan(n_deref8 * 100.0f + 100.0f) &&
        (n_deref8 * 100.0f + 100.0f <= 65535.0F && n_deref8 * 100.0f + 100.0f >=
         0.0F) ? (uint16_t) (n_deref8 * 100.0f + 100.0f) : 9999U;
    
    float n_deref9 = n_var1->throttle;
    
    *&n_ref1->servo8_raw = !(bool) isnan(n_deref9 * 100.0f + 100.0f) &&
        (n_deref9 * 100.0f + 100.0f <= 65535.0F && n_deref9 * 100.0f + 100.0f >=
         0.0F) ? (uint16_t) (n_deref9 * 100.0f + 100.0f) : 9999U;
    mavlink_servo_output_raw_msg_send(n_ref1, n_var2, n_var3);
}

void gcs_transmit_send_gps_raw_int(struct position* n_var0, uint8_t* n_var1,
                                   uint8_t n_var2[80U])
{
    int32_t n_deref0 = n_var0->lat;
    int32_t n_deref1 = n_var0->lon;
    int32_t n_deref2 = n_var0->alt;
    float n_deref3 = n_var0->dop;
    uint32_t n_deref4 = n_var0->vground;
    float n_deref5 = n_var0->heading;
    uint32_t n_deref6 = n_var0->fix;
    uint8_t n_let7 = n_deref6 == 2U ? 3U : n_deref6 == 1U ? 2U : 0U;
    uint8_t n_deref8 = n_var0->num_sv;
    struct gps_raw_int_msg n_local9 = {.time_usec =0U, .lat =n_deref0, .lon =
                                       n_deref1, .alt =n_deref2, .eph =
                                       !(bool) isnan(100.0f * n_deref3) &&
                                       (100.0f * n_deref3 <= (float) 65535U &&
                                        100.0f * n_deref3 >=
                                        (float) 0U) ? (uint16_t) (100.0f *
                                                                  n_deref3) : 0U,
                                       .epv =65535U, .vel =n_deref4 <=
                                       (uint32_t) 65535U && n_deref4 >=
                                       (uint32_t) 0U ? (uint16_t) n_deref4 : 0U,
                                       .cog =!(bool) isnan(100.0f * n_deref5) &&
                                       (100.0f * n_deref5 <= (float) 65535U &&
                                        100.0f * n_deref5 >=
                                        (float) 0U) ? (uint16_t) (100.0f *
                                                                  n_deref5) : 0U,
                                       .fix_type =n_let7, .satellites_visible =
                                       n_deref8};
    struct gps_raw_int_msg* n_ref10 = &n_local9;
    
    mavlink_gps_raw_int_msg_send(n_ref10, n_var1, n_var2);
    return;
}

void gcs_transmit_send_global_position_int(struct position* n_var0,
                                           struct sensors_result* n_var1,
                                           uint32_t n_var2, uint8_t* n_var3,
                                           uint8_t n_var4[80U])
{
    int32_t n_deref0 = n_var0->lat;
    int32_t n_deref1 = n_var0->lon;
    int32_t n_deref2 = n_var0->alt;
    float n_deref3 = n_var1->yaw;
    float n_let4 = 18000.0f / 3.1415927f * n_deref3;
    int32_t n_deref5 = n_var0->vnorth;
    int32_t n_deref6 = n_var0->veast;
    int32_t n_deref7 = n_var0->vdown;
    struct global_position_int_msg n_local8 = {.time_boot_ms =n_var2, .lat =
                                               n_deref0, .lon =n_deref1, .alt =
                                               n_deref2, .relative_alt =
                                               n_deref2, .vx =n_deref5 <=
                                               (int32_t) 32767 && n_deref5 >=
                                               (int32_t) -32768 ? (int16_t) n_deref5 : 0,
                                               .vy =n_deref6 <=
                                               (int32_t) 32767 && n_deref6 >=
                                               (int32_t) -32768 ? (int16_t) n_deref6 : 0,
                                               .vz =-(1 * (n_deref7 <=
                                                           (int32_t) 32767 &&
                                                           n_deref7 >=
                                                           (int32_t) -32768 ? (int16_t) n_deref7 : 0)),
                                               .hdg =!(bool) isnan(n_let4) &&
                                               (n_let4 <= (float) 65535U &&
                                                n_let4 >=
                                                (float) 0U) ? (uint16_t) n_let4 : 0U};
    struct global_position_int_msg* n_ref9 = &n_local8;
    
    mavlink_global_position_int_msg_send(n_ref9, n_var3, n_var4);
    return;
}

void gcs_transmit_send_param_value(struct param_value_msg* n_var0,
                                   uint8_t* n_var1, uint8_t n_var2[80U])
{
    mavlink_param_value_msg_send(n_var0, n_var1, n_var2);
}

void gcs_transmit_send_radio(struct radio_stat* n_var0, uint8_t* n_var1,
                             uint8_t n_var2[80U])
{
    uint16_t n_deref0 = n_var0->tx_err;
    uint16_t n_deref1 = n_var0->ecc_errs;
    uint8_t n_deref2 = n_var0->loc_rssi;
    uint8_t n_deref3 = n_var0->rem_rssi;
    uint8_t n_let4 = 0U;
    uint8_t n_deref5 = n_var0->loc_noise;
    uint8_t n_deref6 = n_var0->rem_noise;
    struct radio_msg n_local7 = {.rxerrors =n_deref0, .fixed =n_deref1, .rssi =
                                 n_deref2, .remrssi =n_deref3, .txbuf =n_let4,
                                 .noise =n_deref5, .remnoise =n_deref6};
    struct radio_msg* n_ref8 = &n_local7;
    
    mavlink_radio_msg_send(n_ref8, n_var1, n_var2);
}