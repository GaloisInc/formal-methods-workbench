package EventTest
public 
   with Base_Types;
   
system Counter
	features
		Output: out event data port Base_Types::Integer;
			
	annex agree {** 
		guarantee "Counter" : event(Output) => Output = (0 -> (pre(Output) + 1));
	**};
	
end Counter ; 
   
   
system Filter
	features
		Input: in event data port Base_Types::Integer;
		Output: out event data port Base_Types::Integer;
			
	annex agree {** 
		
		guarantee "Filter" : event(Output) = (event(Input) and not (Input mod 7 = 0));
		
		guarantee "Forward" : event(Output) => Output = Input ;
		
		
		
		--proposal
		---out event Output1 : fireCondition(Input ...); --no outputs.
		---out event Output2 : fireCondition(Input ...);
		
		
		-- guarantee : something1(Output1);
		-- guarantee : something2(Output1, Output2, Input1, Input2);
		
		--generated:
		--guarantee "Output1 fireCondition guarantee" : event(Output1) <=> (event(Input) and event(...) and fireCondition(Input ...));
		--guarantee "something2" : event(Output1) and event(Output2) and event(Input1) and event(Input2) => something(Output1, Output2, Input1, Input2);
		
		

	**};	
end Filter ; 


system Target
	features
		Input: in event data port Base_Types::Integer;
			
	annex agree {** 
		assume "Target" : event(Input) => (not (Input mod 7 = 0)) ;
	**};
	
end Target ; 

   
system top_level
	annex agree {**
	**};	
end top_level;

system implementation top_level.Impl
	subcomponents
		counter : system Counter ;
		filter : system Filter ;
		target : system Target ;
	connections
		counter_to_sieve : port counter.Output -> filter.Input {Communication_Properties::Timing => immediate;};
		filter_to_target : port filter.Output -> target.Input {Communication_Properties::Timing => immediate;};
	annex agree{**	

		
	**};
	
end top_level.Impl;
	
end EventTest;