import "Common.stg"
import "CommonOSSpecificNames.stg"
import "CommonCPrototypes.stg"
import "LinuxAssemblyHeader.stg"

/*********************************************************************
 *
 *********************************************************************/

////////////////////////////////////////////////////////////////////////////
//
// Declarations related to component gluecode C files for CAmkES/eChronos
//
//
////////////////////////////////////////////////////////////////////////////

mainGlueCodeCFilePurpose(name) ::= <<
This C file contains the main function for model <name>.

>>

filePrefix(name, date, path) ::=
    "<stdFilePrefix(date, path, mainGlueCodeCFilePurpose(name))>"

filePostfix(name, path) ::= <<


<blockComment(arg={End of autogenerated file: <path>})>
>>

constructThreadDispatcher(sem) ::= <<
tb_sem_create(&<sem>);
>>

destructSem(sem) ::= <<
tb_sem_destroy(&<sem>);
>>

createMutex(mutex) ::= <<
tb_interproc_mutex_create(&<mutex>);
>>

destroyMutex(mutex) ::= <<
tb_mutex_destroy(&<mutex>);
>>

createActiveThreadMutexes(threadImpl) ::= <<
<constructThreadDispatcher(threadImpl.threadDispatcherMutex)>
<threadImpl.externalMutexes:{ m |<createMutex(m)>}>
>>

createPassiveThreadMutexes(threadImpl) ::= <<
<constructThreadDispatcher(threadImpl.threadDispatcherMutex)>
<threadImpl.externalMutexes:{ m |<createMutex(m)>}>
>>

createMutexes(model) ::= <<
/* create system-implementation level external mutexes */
<model.externalMutexList:{ m |<createMutex(m)>}>

/* create active thread mutexes */
<model.activeThreadImplementations:createActiveThreadMutexes()>

/* create monitor mutexes */
<model.passiveThreadImplementations:createPassiveThreadMutexes()>
>>

destructActiveThreadMutexes(threadImpl) ::= <<
<destructSem(threadImpl.threadDispatcherMutex)>
<threadImpl.externalMutexes:{ m | <destructMutex(m)> }>
>>

destructPassiveThreadMutexes(threadImpl) ::= <<
<destructSem(threadImpl.threadDispatcherMutex)>
<threadImpl.externalMutexes:{ m | <destructMutex(m)> }>
>>

destructMutexes(model) ::= <<
/* destruct system-implementation level external mutexes */
<model.externalMutexList:{ m | <destructMutex(m)> }>

/* destruct active thread mutexes */
<model.activeThreadImplementations:destructActiveThreadMutexes()>

/* destruct monitor mutexes */
<model.passiveThreadImplementations:destructPassiveThreadMutexes()>
>>

threadInitializePorts(threadImpl) ::= <<
<threadImpl.portList:{ port |<port.linuxAddMainCFileInitializers> }>
>>

initializePorts(model) ::= <<
/*  initializing ports */
<model.activeThreadImplementations:threadInitializePorts()>
>>

threadDestructPorts(threadImpl) ::= <<
<threadImpl.portList:{port |<port.linuxAddMainCFileDestructors>}>
>>

destructPorts(model) ::= <<
<model.activeThreadImplementations:threadDestructPorts()>
>>

// currently right here!

createThread(threadImpl) ::= <<
TB_THREAD_TYPE <threadImpl.normalizedName>;
tb_thread_create(&<threadImpl.normalizedName>,
   <threadImpl.priority>,
   <threadImpl.threadImplMainFnName>,
   NULL);

>>

joinThread(threadImpl) ::= <<
pthread_join(<threadImpl.normalizedName>, NULL);

>>

createProcess(process) ::= <<
// we might want to track the PID, but I'm not doing it at the moment.
if (fork() == 0) {
    ////////////////////////////////////////////////////////////////
    //
    // This code creates process <process.tbAst.name>
    // TODO: code HERE to drop rights for the process from root to
    // something more sensible.
    //
    ////////////////////////////////////////////////////////////////
    <process.threadImplementationList:createThread()>

    <process.threadImplementationList:joinThread()>
} else >>

createProcesses(model) ::= <<
<model.processImplementations:createProcess()>
    ;  // dummy statement for final 'else' branch.
>>

destructTasks(model) ::= <<
>>

sharedDataDefinition(sharedData) ::= <<
<sharedData.type.name> <sharedData.varName>;

>>

/////////////////////////////////////////////////////////////////////
//
// Main function
//
/////////////////////////////////////////////////////////////////////
mainFunction(model) ::= <<
int trusted_build_main(uint32_t runDurationInSeconds) {

    <createMutexes(model)>

    <initializePorts(model)>

    <createProcesses(model)>

    if (runDurationInSeconds == 0) {
        // Wait for all child processes to finish.
        // should wait forever unless all child processes crash.
        while (wait(NULL) > 0);
    } else {
        // Wait for the specified time then pull the plug.
        // when the top-level process finishes, the children will be killed.
        sleep(runDurationInSeconds);
    }

    /* if bounded-time run, kill the tasks and destruct the mutexes */

    <destructTasks(model)>

    <destructPorts(model)>

    <destructMutexes(model)>

    return 0;
}
>>

writeThreadPortIncludes(threadImpl) ::= <<
<threadImpl.portList:{port|<port.linuxAddMainCFileIncludes>}>
>>

writeThreadPortDeclarations(threadImpl) ::= <<
<threadImpl.portList:{port|<port.linuxAddMainCFileDeclarations>}>
>>


///////////////////////////////////////////////////////////////////////////
//
// Putting it all together...
//
///////////////////////////////////////////////////////////////////////////

body(model) ::= <<

#include <\u0022><model.prefix>_decls.h<\u0022>
#include <\u003C>unistd.h<\u003E>
#include <\u003C>assert.h<\u003E>

<model.threadImplementations:writeThreadPortIncludes()>


<if(model.sharedData)>
// shared data definitions for tasks
<model.sharedData:sharedDataDefinition()>
<endif>

<writeModelMutexes(model, "")>

<model.threadImplementations:writeThreadPortDeclarations()>

<mainFunction(model)>

>>
