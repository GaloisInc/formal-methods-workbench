import "Common.stg"

////////////////////////////////////////////////////////////////////////////
//
// Declarations for camkes assembly
//
////////////////////////////////////////////////////////////////////////////

constructPeriodicComponent(calendar) ::= <<
<if(calendar.hasDispatchers)>
component <calendar.periodicDispatcherComponentName> <calendar.periodicDispatcherInstanceName>;
<endif>
>>

camkesAssemblyPurpose(sysInstanceName) ::= <<
This file contains the main CAmkES assembly for the
AADL system instance rooted at <sysInstanceName>.
>>

filePrefix(name, date, path) ::= "<stdFilePrefix(date, path, camkesAssemblyPurpose(name))>"

filePostfix(name, path) ::= <<
>>

createVMInit(vm) ::= <<
component Init<vm.vmNumber> {
    <vm.vmCrossingConnections: {conn | <conn.camkesAddAssemblyFileVMPortDeclarations> }>
    VM_INIT_DEF()
}

>>


assemblyThreadImplementationImports(threadImpl) ::= <<
import "<threadImpl.rootToCamkesComponentFilePath>";
<threadImpl.portList: {port | <port.camkesAddAssemblyFilePortDeclarations>} >

>>

monitorPerConnection(cnxshn) ::= <<
component Monitor_<cnxshn.name> monitor_<cnxshn.name>;

>>

monitorGeneration(port) ::= <<
<port.connections:monitorPerConnection()>
>>

assemblyThreadComponent(threadImpl) ::= <<
component <threadImpl.componentName> <threadImpl.componentInstanceName>;
<threadImpl.inputEventPortList:monitorGeneration()>
<threadImpl.inputEventDataPortList:monitorGeneration()>
>>


assemblyConnectActiveToPassiveThreads(threadImpl, model) ::= <<
<threadImpl.passiveThreadRegion:connectPassiveToActive(threadImpl, model)>
>>


connectRpg(endpointConnection, srcThreadImpl, model) ::= <<
<rpcConnection(model.generateConnectionName,
    srcThreadImpl.componentInstanceName,
    endpointConnection.requiresEndpoint.name,
    endpointConnection.providesThreadImplementation.componentInstanceName,
    endpointConnection.providesEndpoint.name)>
>>

assemblyConnectRpgs(threadImpl, model) ::= <<
<threadImpl.isRequiresOfConnectionList:connectRpg(threadImpl, model)>
>>

assemblyConnectAccessor(sharedDataAccessor, otherSda, model) ::= <<
<sdaConnection(model.generateConnectionName,
               sharedDataAccessor.owner.componentInstanceName,
               sharedDataAccessor.name,
               otherSda.owner.componentInstanceName,
               otherSda.name)>
>>

assemblyConnectSharedData(sharedData, model) ::= <<
<sharedData.nonChosenAccessList:assemblyConnectAccessor(sharedData.chosenAccess, model)>
>>

assemblySetPriorities(threadImpl) ::= <<
<if(!threadImpl.isExternal)>
<threadImpl.componentInstanceName>.priority = <threadImpl.priority>;
<endif>
>>

assemblySetStackSize(threadImpl) ::= <<
<if(!threadImpl.isExternal)>
<threadImpl.componentInstanceName>._control_stack_size = <threadImpl.osSpecificStackSize>;
<endif>
>>

assemblySetSchedulingContext(threadImpl) ::= <<
// MWW: todo: set scheduling contexts for interfaces for thread <threadImpl.componentInstanceName>.

>>

assemblySetTiming(threadImpl) ::= <<
<threadImpl.componentInstanceName>._period = <threadImpl.periodInMicroseconds>;
<threadImpl.componentInstanceName>._budget = <threadImpl.maxExecutionTimeInMicroseconds>;

>>

assemblyConnectTimeServices(threadImpl, model) ::= <<
<if(threadImpl.requiresTimeServices)><\\>
<if(model.externalTimerComponent)>
connection seL4TimeServer <threadImpl.timeServicesConnectionName>(from <threadImpl.componentInstanceName>.timer, to <model.camkesExternalTimerInterfacePath>);
<else>
connection seL4TimeServer <threadImpl.timeServicesConnectionName>(from <threadImpl.componentInstanceName>.timer, to time_server.the_timer);
<endif>
<endif>
>>

configActiveToPassiveDataportId(passiveThreadImpl, activeThreadImpl, model) ::= <<
<if(passiveThreadImpl.containsDispatchers)><\\>
<activeThreadImpl.componentInstanceName>.<passiveThreadImpl.componentInstanceName>_attributes = "<model.generateCamkesDataportRpcMinIndex>";
<endif>
>>

configActiveToPassiveRegionDataportId(threadImpl, model) ::= <<
<threadImpl.passiveThreadRegion:configActiveToPassiveDataportId(threadImpl, model)>

>>

configConnectTimeServices(threadImpl, model) ::= <<
<if(threadImpl.requiresTimeServices)>
<threadImpl.componentInstanceName>.timer_attributes = "<model.generateCamkesTimeServerThreadIndex>";
<threadImpl.componentInstanceName>.timer_global_endpoint = "<threadImpl.timeServicesConnectionName>";
<threadImpl.componentInstanceName>.timer_complete_global_endpoint = "<threadImpl.timeServicesConnectionName>";
<endif>
>>

portDeclarations(threadImpl) ::= <<
<threadImpl.portList:{port | <port.camkesAddAssemblyFileCompositionPortDeclarations>
}>
>>

configurePorts(threadImpl) ::= <<
<threadImpl.portList:{port | <port.camkesAddAssemblyFileConfigDeclarations>
}>
>>

composeVms(model) ::= <<
<model.virtualMachineList: {vm |
// Need to make sure this correctly ties a number to the model <vm.pathName>
VM_PER_VM_COMP_DEF(<vm.vmNumber>)
<vm.vmCrossingConnections:{conn | <conn.camkesAddAssemblyFileVMCompositionPortDeclarations>} >
}>

>>

configVms(model) ::= <<
<model.virtualMachineList: {vm |
// Need something here tying the second number to the first model <model>
// Temporarily here I will just use the iteration number
<vm.perVmConfigDefs>

}>

>>

camkesAssemblyBody(model) ::= <<

import \<std_connector.camkes>;

<if(model.containsVM)>
#include \<configurations/vm.h>
<endif>
<if(model.threadCalendar.hasDispatchers)>
import "<model.threadCalendar.periodicDispatcherPathName>";
<if(!model.externalTimerComponent)>
<if(model.isQemuTarget)>
import \<TimeServerKZM/TimeServer.camkes>;
<elseif(model.isOdroidTarget)>
import \<TimeServerOdroid/TimeServer.camkes>;
<else>
// TODO: MWW: Add import for platform time server .camkes file HERE.  Only know ARM-QEMU and ODROID time server.
<endif>
<else>
// TODO: MWW: not sure what (if anything) needs to be imported for external timer component.
<endif>
<endif>

<model.portListEmitterAssemblyIdlImports>

<model.threadImplementations:assemblyThreadImplementationImports()>

<\\>


<if(model.containsVM)>
<model.virtualMachineList:createVMInit()>
<endif>

assembly {
    composition {
        <if(model.containsVM)>
        VM_COMPOSITION_DEF()
        <composeVms(model)>
        <endif>
        <constructPeriodicComponent(model.threadCalendar)><\\>

        <if(model.threadCalendar.hasDispatchers && !model.externalTimerComponent)>
        <if(model.isQemuTarget)>
        component TimeServerKZM time_server;
        <elseif(model.isOdroidTarget)>
        component TimeServerOdroid time_server;
        <else>
        // MWW TODO: Fill in time server component HERE.  Need to determine time server for Intel platforms.
        <endif>
        <endif>

        <commentIf("Component instances for all AADL-defined threads",
                   (model.threadImplementations:assemblyThreadComponent()))><\\>

        <commentIf("Port declarations and connections for active threads",
                   (model.activeThreadImplementations:portDeclarations()))><\\>
        

        <if(model.threadCalendar.hasDispatchers)>
        <if(!model.externalTimerComponent)>
        connection seL4TimeServer periodic_dispatch_timer(from <model.threadCalendar.periodicDispatcherInstanceName>.timer, to time_server.the_timer);
        connection seL4GlobalAsynchCallback echo_int(from time_server.timer_notification, to <model.threadCalendar.periodicDispatcherInstanceName>.timer_complete);
        <else>
        connection seL4TimeServer periodic_dispatch_timer(from <model.threadCalendar.periodicDispatcherInstanceName>.timer, to <model.camkesExternalTimerInterfacePath>);
        connection seL4GlobalAsynchCallback echo_int(from <model.camkesExternalTimerCompletePath>, to <model.threadCalendar.periodicDispatcherInstanceName>.timer_complete);
        <endif>
        <endif>


        <model.threadImplementations:assemblyConnectTimeServices(model)><\\>

        <commentIf("Direct RPC connections",
                   (model.threadImplementations:assemblyConnectRpgs(model)))><\\>

        <commentIf("Shared memory connections",
                   (model.sharedData:assemblyConnectSharedData(model)))>
    }

    configuration {
        <if(model.containsVM)>
        VM_CONFIGURATION_DEF()
        <configVms(model)>
        <endif>
        <if(model.threadCalendar.hasDispatchers)>
        <model.threadCalendar.periodicDispatcherInstanceName>.timer_attributes = "<model.generateCamkesTimeServerThreadIndex>";
        <model.threadCalendar.periodicDispatcherInstanceName>.timer_global_endpoint = "periodic_dispatcher_timer";
        <model.threadCalendar.periodicDispatcherInstanceName>.timer_complete_global_endpoint = "periodic_dispatcher_timer";
        <model.threadCalendar.periodicDispatcherInstanceName>.priority = 201;
        <endif>
        
        
        <commentIf("Component port configuration declarations",
                   (model.threadImplementations:configurePorts()))><\\>
        
        <model.threadImplementations:assemblySetPriorities()>
        <model.threadImplementations:assemblySetStackSize()>
        <if(model.useOSRealTimeExtensions)>
        <model.threadImplementations:assemblySetSchedulingContext()>
        <model.activeThreadImplementations:assemblySetTiming()>
        <endif>
        <model.threadImplementations:configConnectTimeServices(model)>
        <model.activeThreadImplementations:configActiveToPassiveRegionDataportId(model)>
    }
}

>>

