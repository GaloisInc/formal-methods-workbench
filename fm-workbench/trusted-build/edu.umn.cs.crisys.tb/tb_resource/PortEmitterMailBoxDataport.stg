import "Common.stg"

///////////////////////////////////////////////////////////////////////////////////////////////
// Structure Definitions
///////////////////////////////////////////////////////////////////////////////////////////////

DefineWriterStructure(port) ::= <<
// Handle providing all the relevant pointer to the shared state
struct mb_<port.qualifiedName>_internals {
    // points to an area of size data_size*(n_readers+2),
    // writer has read-write access, readers have read-only access
    void * data_area;
    // An array of size n_readers of pointers to mb_id
    // Writer has write access to all
    // Readers each have write access to their own, and no access to others
    volatile mb_id *indices[<port.connectionSize>];
};

// Local state of the writer
struct mb_<port.qualifiedName>_w_handle {
    struct mb_info * info;
    struct mb_<port.qualifiedName>_internals * shared_data;

    // when write_active - the index of the write buffer inside, Empty otherwise
    mb_id current_area;

    // last area fully written
    mb_id last_written;

    // An array of size n_readers of indices that each reader was last seen taking
   // mb_id * last_read;
      mb_id  last_read[<port.connectionSize>];

    // An array of size n_readers+2 of bools.
    // This is a non-persistent data structure that is only included in the handle 
    // to simplify memory management
    // bool * available;
       bool  available[<port.availableStructureSize>];

};

>>


DefineReaderStructure(port) ::= <<
// API for "supervisor" level mailbox initialization

#pragma once

#include <\u003C>stddef.h<\u003E>
#include <\u003C>stdbool.h<\u003E>

// Type to use for entity identifiers
// Specifically, used both for:
//   - reader id: 0..n_readers-1
//   - data area id: 0..n_readers+1
// Could be a large type if we wanted to support more than 253 readers.
typedef int mb_id;

// Constants for data areas. Specific values do not matter, as long as
//    MB_Empty is distinct from all valid data area ids
//    MB_First is a valid data area id
static const mb_id MB_Empty = -1;
static const mb_id MB_First = 0;

struct mb_info {
    // sizeof(struct mb_data), possibly rounded up for page alignment
    size_t data_size;

    // Total numbers of readers of mailbox
    mb_id n_readers;
};


// Local state of the reader
struct mb_r_handle {
    struct mb_info * info;
    void * data_area;
    mb_id last_read;
    volatile mb_id * my_idx;
    // true in between mb_start_read and mb_finish_read
    // Not sure whether this is actually needed.
    //bool read_active;
};

>>
///////////////////////////////////////////////////////////////////////////////////////////////
//         Prototypes Header
///////////////////////////////////////////////////////////////////////////////////////////////

mailboxReaderPrototype(port) ::= <<
void * mb_start_read_<port.singletonConnection.sourcePort.qualifiedName>(void);
void mb_init_read_<port.singletonConnection.sourcePort.qualifiedName>(const int64_t * initializer);
void mb_finish_read_<port.singletonConnection.sourcePort.qualifiedName>(void);
<port.type.name> * <port.name>;
>>
mailboxWriterPrototype(port) ::= <<
void * mb_start_write_<port.qualifiedName>(void);
void mb_init_write_<port.qualifiedName>(const int64_t * initializer);
void mb_finish_write_<port.qualifiedName>(void);
<port.type.name> * <port.name>;
>>


/////////////////////////////////////////////////////////////////////////////////////////////////
//               Declarations
///////////////////////////////////////////////////////////////////////////////////////////////////



componentRemoteWriterDecl(srcPort) ::= <<
struct mb_<srcPort.qualifiedName>_w_handle <srcPort.qualifiedName>_handle_gv;
struct mb_info <srcPort.qualifiedName>_info;
struct mb_<srcPort.qualifiedName>_internals <srcPort.qualifiedName>_shared_memory;


void * mb_start_write_<srcPort.qualifiedName>(void) {

    // Handle incorrect usage of the API - may want an assert(==Empty) instead
    if (<srcPort.qualifiedName>_handle_gv.current_area != MB_Empty) {
        mb_finish_write_<srcPort.qualifiedName>();
    }

    // Find an unused work area
     mb_id n_areas = <srcPort.qualifiedName>_handle_gv.info-<\u003E>n_readers+2;

    for (mb_id i=0; i <\u003C> n_areas; i++) {
        <srcPort.qualifiedName>_handle_gv.available[i]=true;
    }

    for (mb_id i=0; i <\u003C> <srcPort.qualifiedName>_handle_gv.info-<\u003E>n_readers; i++) {
        <srcPort.qualifiedName>_handle_gv.available[<srcPort.qualifiedName>_handle_gv.last_read[i]] = false;
    }
    <srcPort.qualifiedName>_handle_gv.available[<srcPort.qualifiedName>_handle_gv.last_written] = false;

    mb_id new_area=0;
    while (!<srcPort.qualifiedName>_handle_gv.available[new_area]) {
        new_area++;
        assert(new_area <\u003C> n_areas);
    }
    <srcPort.qualifiedName>_handle_gv.current_area=new_area;

    return <srcPort.qualifiedName>_handle_gv.shared_data-<\u003E>data_area + <srcPort.qualifiedName>_handle_gv.info-<\u003E>data_size * <srcPort.qualifiedName>_handle_gv.current_area;
}

void mb_finish_write_<srcPort.qualifiedName>(void) {

    // Handle incorrect usage of the API - may want an assert(!=Empty) instead
    if (<srcPort.qualifiedName>_handle_gv.current_area == MB_Empty) {
        return;
    }
    for (mb_id i=0; i <\u003C> <srcPort.qualifiedName>_handle_gv.info-<\u003E>n_readers; i++) {
        mb_id taken = __atomic_exchange_n(<srcPort.qualifiedName>_handle_gv.shared_data-<\u003E>indices[i],<srcPort.qualifiedName>_handle_gv.current_area,__ATOMIC_RELEASE);
        if (taken == MB_Empty) {
            <srcPort.qualifiedName>_handle_gv.last_read[i]=<srcPort.qualifiedName>_handle_gv.last_written;
        }
    }

    <srcPort.qualifiedName>_handle_gv.last_written = <srcPort.qualifiedName>_handle_gv.current_area;
    <srcPort.qualifiedName>_handle_gv.current_area = MB_Empty;
}


void mb_init_write_<srcPort.qualifiedName>(const int64_t * initializer)
{

  // Init the mailbox description
  <srcPort.qualifiedName>_info.data_size = sizeof(<srcPort.type.name>);
  <srcPort.qualifiedName>_info.n_readers = <srcPort.connectionSize>;

  // Point to the N+1 shared memory areas for the mailboxes
  <srcPort.qualifiedName>_shared_memory.data_area = (void *) <srcPort.qualifiedName>;
  <srcPort.arrayInitialization>

   //if n_readers is hardcoded, the next two can be just pointers to global arrays of the right size, instead of dynamically allocated
    <srcPort.qualifiedName>_handle_gv.info = &<srcPort.qualifiedName>_info;
    <srcPort.qualifiedName>_handle_gv.shared_data = &<srcPort.qualifiedName>_shared_memory;
    <srcPort.qualifiedName>_handle_gv.current_area = MB_Empty;
    <srcPort.qualifiedName>_handle_gv.last_written = MB_First;
    for (mb_id i = 0; i <\u003C> <srcPort.qualifiedName>_handle_gv.info-<\u003E>n_readers; i++) {
        <srcPort.qualifiedName>_handle_gv.last_read[i] = MB_First;
    }


}

 >>


componentLocalReaderDecl(port) ::= <<
struct mb_r_handle <port.name>_handle_gv;
struct mb_info <port.name>_info;

void mb_init_read_<port.singletonConnection.sourcePort.qualifiedName>(const int64_t * initializer)
{
  <port.name>_info.data_size = sizeof(<port.type.name>);
  <port.name>_info.n_readers = <port.singletonConnection.sourcePort.connectionSize>;
  <port.name>_handle_gv.info = &<port.name>_info;
  <port.name>_handle_gv.data_area = (void *) <port.singletonConnection.sourcePort.qualifiedName>;
  <port.name>_handle_gv.my_idx = (mb_id*) <port.singletonConnection.name>;
  <port.name>_handle_gv.last_read = MB_Empty;

}

void * mb_start_read_<port.singletonConnection.sourcePort.qualifiedName>(void) {


   mb_id written_id = __atomic_exchange_n (<port.name>_handle_gv.my_idx, MB_Empty, __ATOMIC_ACQUIRE);

    if (written_id == MB_Empty) {
        written_id = <port.name>_handle_gv.last_read;
    } else {
        if (written_id <\u003C> 0 || written_id <\u003E>= <port.name>_handle_gv.info-<\u003E>n_readers+2) {
            written_id = <port.name>_handle_gv.last_read;
            // Writer is malicious.
            // XXX: In production would want to report an error and continue,
            // but for testing do an assert
            assert(0);
        }
        assert(<port.name>_handle_gv.last_read!=written_id);
        <port.name>_handle_gv.last_read = written_id;
    }
    return <port.name>_handle_gv.data_area + <port.name>_handle_gv.info-<\u003E>data_size * written_id;
}

void mb_finish_read_<port.singletonConnection.sourcePort.qualifiedName>(void) {
    //<port.name>_handle_gv.read_active = false;
}

>>


////////////////////////////////////////////////////////////////////////////////////
// Camkes Component declaration File
//
///////////////////////////////////////////////////////////////////////////////////


createReaderDataport(connection) ::= <<
dataport mast_reader_buff <connection.name>;
>>

createWriterDataport(port) ::= <<
dataport <port.mailboxStructTypeName> <port.qualifiedName>;
>>

inputDataPortDecl(port) ::= <<
// Check one writer to this port.  We can do that by checking
// the size of the connection list.  It should be size 1.
// If so, we will access the port writer (which will be the only element
// in the list).  Then we will also add a dataport for ourselves.
<createReaderDataport(port.singletonConnection)>
<createWriterDataport(port.singletonConnection.sourcePort)>
>>

outputDataPortDecl(port) ::= <<
<createWriterDataport(port)>
<port.connections:createReaderDataport()>
>>

/////////////////////////////////////////////////////////////////////////////////////
///
/////////////////////////////////////////////////////////////////////////////
osSpecificIncludeFiles(threadImpl) ::= <<
#include <\u003C>assert.h<\u003E>
#include <\u003C>sync/atomic.h<\u003E>
#include <\u003C>stdlib.h<\u003E>
#include <\u003C>stdio.h<\u003E>
#include <\u003C>assert.h<\u003E>
>>



///////////////////////////////////////////////////////////////////////////////////
// Camkes Assembly declaration section
///////////////////////////////////////////////////////////////////////////////////

sdaConnection(cid, from1, from2, to1, to2) ::=
   "connection seL4SharedData <cid> (from <from1>.<from2>, to <to1>.<to2>);"

mailboxWriterToReader(connection) ::= <<
<sdaConnection(connection.name,
        connection.sourcePort.threadImplementation.componentInstanceName,
        connection.name,
        connection.destPort.threadImplementation.componentInstanceName,
        connection.name)>
>>

mailboxWriterBufferConnection(connection) ::= <<
<sdaConnection(connection.fullyQualifiedName,
        connection.sourcePort.threadImplementation.componentInstanceName,
        connection.sourcePort.qualifiedName,
        connection.destPort.threadImplementation.componentInstanceName,
        connection.sourcePort.qualifiedName)>
>>

connectReaderWriter(connection) ::= <<
<if(connection.sourcePort.isOutputData)><\\>
// Connect all of the defined reader dataports for mailboxes + the writer buffer.
<mailboxWriterToReader(connection)>
<mailboxWriterBufferConnection(connection)>
<endif>
>>

configureReaderWriter(connection) ::= <<
<if(connection.sourcePort.isOutputData)><\\>
<connection.fullyQualifiedName>.to_access = "R";
<endif>

>>


///////////////////////////////////////////////////////////////////////////////////////////////
