import "Common.stg"

///////////////////////////////////////////////////////////////////////////
//
// Templates for managing all event port interfaces between active threads.
// The implementation generates separate monitor comopenents for each unique
// input port of that type.
// 
// 01/11/2017 DWD
// 
///////////////////////////////////////////////////////////////////////////

filePrefix(purpose, date, path) ::= "<stdFilePrefix(date, path, purpose)>"

inputPortCamkesMonitorPurpose(port) ::= <<
  Monitor of type <port.typeName> with input port <port.qualifiedName>
  queue size of <port.queueSize>. The output port set follows:

<port.connections:{ c |     <c.sourcePort.qualifiedName>
}>
>>

inputPortCMonitorPurpose(port) ::= <<
  Implementing a Monitor of type <port.typeName> with a queue size of 
  <port.queueSize>. The input port that will be calling dequeue and receiving notifications 
  is <port.qualifiedName>. The output port set follows:

<port.connections:{ c |     c.sourcePort
}>
>>

inputPortIDL4MonitorPurpose(port,str_direction) ::= <<
  <str_direction> interface with type <port.typeName> and queue size of <port.queueSize>.
}>
>>

preinitStatements(port) ::= <<
    q<port.name>_reg_callback(q<port.name>_handler,NULL);

>>
///////////////////////////////////////////////////////////////////////////
//
// Header templates
//
///////////////////////////////////////////////////////////////////////////

writeExternalHandlerUdePrototype(externalHandler, dispatcher) ::= <<
<if(dispatcher.hasData)>
void <externalHandler.handlerName>(const <dispatcher.type.aadlInputType.name> <dispatcher.name>);
<else>
void <externalHandler.handlerName>(void);
<endif>

>>

writeUdePrototype(dispatcher) ::= <<
<commentIf({user dispatch entrypoints for port <dispatcher.name>},
           (dispatcher.externalHandlers:writeExternalHandlerUdePrototype(dispatcher)))>

>>

writePortWriterPrototype(port) ::= <<
<if(port.hasData)>
bool <port.localWriterName>(const <port.type.aadlInputType.name> <port.name>);
<else>
bool <port.localWriterName>(void);
<endif>

>>

writePortReaderPrototype(port) ::= <<
// reader prototype for <port.name>
<if(port.hasData)>
bool <port.localReaderName>(<port.type.aadlOutputType.name> <port.name>);
<else>
bool <port.localReaderName>(void);
<endif>

>>



///////////////////////////////////////////////////////////////////////////
//
// C File templates
//
///////////////////////////////////////////////////////////////////////////


InputEventDataPortDecls(port) ::= <<

/************************************************************************
 *  <port.incomingWriterName>:
 * Invoked by: remote interface.
 *
 * This is the function invoked by a remote RPC to write to an active-thread
 * input event data port.  It queues the input message into a circular buffer.
 *
 ************************************************************************/

bool <port.incomingWriterName>(const <port.type.camkesInputType.name> arg) {
    bool result;
    result = <port.queueWriteName>(<port.type.camkesInputToAadlInput> arg);
    return result;
}

>>

InputEventPortDecls(port) ::= <<


/************************************************************************
 *  <port.localReaderName>:
 * Invoked from local active thread.
 *
 * This is the function invoked by the active thread to decrement the
 * input event index.
 *
 ************************************************************************/

bool <port.localReaderName>() {
    bool result;
    <port.lockStmt>
    if (<port.index> > 0) {
        <port.index>--;
        result = true;
    } else {
        result = false;
    }
    <port.unlockStmt>
    return result;
}

>>


///////////////////////////////////////////////////////////////
//
// Writer functions
//
///////////////////////////////////////////////////////////////


callRemoteWriterStmt(port, dname) ::= << 
<if(port.hasData)>
tb_result &= <dname>_enqueue(<port.type.aadlInputToCamkesInput><port.name>);
<else>
tb_result &= <dname>_enqueue();
<endif>
>>

remoteCallerFunction(port) ::= <<
/************************************************************************
 *  <port.localWriterName>:
 * Invoked from user code in the local thread.
 *
 * This is the function invoked by the local thread to make a
 * call to write to a remote data port.
 *
 * XXX: When simulating fan out, the caller of this function will only 
 * receive a positive response when all enqueues are successful. When a
 * negative response is received it only indicates that at least one
 * enqueue attempt failied.
 *
 ************************************************************************/

<if(port.hasData)>
bool <port.localWriterName>(const <port.type.aadlInputType.name> <port.name>) {
<else>
bool <port.localWriterName>(void) {
<endif>
    bool tb_result = true ; 
    <port.outputMonitorNames:{ n | <callRemoteWriterStmt(port,n)>}>
    return tb_result;
}

>>

componentRemoteWriterDecl(port) ::= <<
<remoteCallerFunction(port)>
>>

///////////////////////////////////////////////////////////////
//
// Dispatch functions
//
///////////////////////////////////////////////////////////////

eventDataDispatcher(dispatcher) ::= <<
while (<dispatcher.localReaderName>(<dispatcher.type.valToAadlOutput><dispatcher.name>)) {
    <dispatcher.activeThreadInternalDispatcherFnName>(<dispatcher.type.valToAadlInput><dispatcher.name>);
}

>>

eventDispatcher(dispatcher) ::= <<
while (<dispatcher.localReaderName>()) {
    <dispatcher.activeThreadInternalDispatcherFnName>();
}

>>


///////////////////////////////////////////////////////////////////////////
//
// CAmkES OS configuration templates
//
///////////////////////////////////////////////////////////////////////////

inputPortDeclarations(port) ::= <<
uses <port.inputMonitorInterfaceName> <port.name>;
consumes QueuedData <port.notificationName>;

>>

outputPortDeclarations(port) ::= <<
<port.outputMonitorNames:{n | uses <port.outputMonitorInterfaceName> <n>;<\n>}>

>>

//monitorCamkesIdl4Writer(iname, str_type_name)
camkesMonitorEnqueueIdl4(str_interface_name, str_type_name, str_types_include) ::= <<
procedure <str_interface_name>_Enqueue {
  include <\u003C>stdbool.h<\u003E>;
  include <\u003C><str_types_include><\u003E>;
  bool enqueue(refin <str_type_name> m);
};
>>

camkesMonitorDequeueIdl4(str_interface_name, str_type_name, str_types_include) ::= <<
procedure <str_interface_name>_Dequeue {
  include <\u003C>stdbool.h<\u003E>;
  include <\u003C><str_types_include><\u003E>;
  bool dequeue(out <str_type_name> m);
};
>>

monitorCamkesWriter(str_component_name,port) ::= <<
import "../../interfaces/<port.inputMonitorInterfaceName>.idl4";
import "../../interfaces/<port.outputMonitorInterfaceName>.idl4";
component <str_component_name> {

  provides <port.outputMonitorInterfaceName> enq;
  provides <port.inputMonitorInterfaceName> deq;
  emits QueuedData qd;
  has mutex q;
}
>>


monitorCamkesCWriter(port, str_types_include) ::= <<
#include <\u003C>stdio.h<\u003E>
#include <\u003C>stdbool.h<\u003E>
#include <\u003C><str_types_include><\u003E>

<port.type.camkesName> contents[<port.queueSize>];
static uint32_t front = 0;
static uint32_t length = 0;

static bool is_full(void) {
  return length == <port.queueSize>;
}

static bool is_empty(void) {
  return length == 0;
}

bool deq_dequeue(<port.typeName> * m) {
  q_lock();
  if (is_empty()) {
    q_unlock();
    return false;
  } else {
    *((<port.type.camkesName> *)m) = contents[front];
    front = (front + 1) % <port.queueSize>;
    length--;
    q_unlock();
    return true;
  }
}

bool enq_enqueue(const <port.typeName> * m) {
  q_lock();
  if (is_full()) {
    q_unlock();
    return false;
  } else {
    contents[(front + length) % <port.queueSize>] = *((<port.type.camkesName> *)m);
    length++;
    qd_emit();
    q_unlock();
    return true;
  }
}

>>

monitorCamkesEventHandler(port,unlock) ::= <<

static void <port.notificationName>_handler(void * unused) {
  <unlock>
  <port.notificationName>_reg_callback(<port.notificationName>_handler, NULL);
}

>>