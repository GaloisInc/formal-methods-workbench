/*
 * generated by Xtext
 */
package edu.uah.rsesc.aadlsimulator.xtext.serializer;

import com.google.inject.Inject;
import com.google.inject.Provider;
import edu.uah.rsesc.aadlsimulator.xtext.inputConstraint.BinaryExpression;
import edu.uah.rsesc.aadlsimulator.xtext.inputConstraint.BooleanLiteral;
import edu.uah.rsesc.aadlsimulator.xtext.inputConstraint.ConstRefExpression;
import edu.uah.rsesc.aadlsimulator.xtext.inputConstraint.ElementRefExpression;
import edu.uah.rsesc.aadlsimulator.xtext.inputConstraint.InputConstraintPackage;
import edu.uah.rsesc.aadlsimulator.xtext.inputConstraint.IntegerLiteral;
import edu.uah.rsesc.aadlsimulator.xtext.inputConstraint.IntervalExpression;
import edu.uah.rsesc.aadlsimulator.xtext.inputConstraint.NegativeExpression;
import edu.uah.rsesc.aadlsimulator.xtext.inputConstraint.PreExpression;
import edu.uah.rsesc.aadlsimulator.xtext.inputConstraint.RandomElementExpression;
import edu.uah.rsesc.aadlsimulator.xtext.inputConstraint.RandomIntegerExpression;
import edu.uah.rsesc.aadlsimulator.xtext.inputConstraint.RandomRealExpression;
import edu.uah.rsesc.aadlsimulator.xtext.inputConstraint.RealLiteral;
import edu.uah.rsesc.aadlsimulator.xtext.inputConstraint.SetExpression;
import edu.uah.rsesc.aadlsimulator.xtext.services.InputConstraintGrammarAccess;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtext.serializer.acceptor.ISemanticSequenceAcceptor;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.diagnostic.ISemanticSequencerDiagnosticProvider;
import org.eclipse.xtext.serializer.diagnostic.ISerializationDiagnostic.Acceptor;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.GenericSequencer;
import org.eclipse.xtext.serializer.sequencer.ISemanticNodeProvider.INodesForEObjectProvider;
import org.eclipse.xtext.serializer.sequencer.ISemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class InputConstraintSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private InputConstraintGrammarAccess grammarAccess;
	
	@Override
	public void createSequence(EObject context, EObject semanticObject) {
		if(semanticObject.eClass().getEPackage() == InputConstraintPackage.eINSTANCE) switch(semanticObject.eClass().getClassifierID()) {
			case InputConstraintPackage.BINARY_EXPRESSION:
				sequence_AddSub_MultDiv(context, (BinaryExpression) semanticObject); 
				return; 
			case InputConstraintPackage.BOOLEAN_LITERAL:
				sequence_BooleanLiteral(context, (BooleanLiteral) semanticObject); 
				return; 
			case InputConstraintPackage.CONST_REF_EXPRESSION:
				sequence_ConstRef(context, (ConstRefExpression) semanticObject); 
				return; 
			case InputConstraintPackage.ELEMENT_REF_EXPRESSION:
				sequence_ElementRef(context, (ElementRefExpression) semanticObject); 
				return; 
			case InputConstraintPackage.INTEGER_LITERAL:
				sequence_IntegerLiteral(context, (IntegerLiteral) semanticObject); 
				return; 
			case InputConstraintPackage.INTERVAL_EXPRESSION:
				sequence_Interval(context, (IntervalExpression) semanticObject); 
				return; 
			case InputConstraintPackage.NEGATIVE_EXPRESSION:
				sequence_Negative(context, (NegativeExpression) semanticObject); 
				return; 
			case InputConstraintPackage.PRE_EXPRESSION:
				sequence_Pre(context, (PreExpression) semanticObject); 
				return; 
			case InputConstraintPackage.RANDOM_ELEMENT_EXPRESSION:
				sequence_RandomElement(context, (RandomElementExpression) semanticObject); 
				return; 
			case InputConstraintPackage.RANDOM_INTEGER_EXPRESSION:
				sequence_RandomInteger(context, (RandomIntegerExpression) semanticObject); 
				return; 
			case InputConstraintPackage.RANDOM_REAL_EXPRESSION:
				sequence_RandomReal(context, (RandomRealExpression) semanticObject); 
				return; 
			case InputConstraintPackage.REAL_LITERAL:
				sequence_RealLiteral(context, (RealLiteral) semanticObject); 
				return; 
			case InputConstraintPackage.SET_EXPRESSION:
				sequence_Set(context, (SetExpression) semanticObject); 
				return; 
			}
		if (errorAcceptor != null) errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Constraint:
	 *     ((left=AddSub_BinaryExpression_1_0 op=AddSubOperator right=MultDiv) | (left=MultDiv_BinaryExpression_1_0 op=MultDivOperator right=Function))
	 */
	protected void sequence_AddSub_MultDiv(EObject context, BinaryExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (value=TRUE | value=FALSE)
	 */
	protected void sequence_BooleanLiteral(EObject context, BooleanLiteral semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (packageSegments+=ID+ constantName=ID)
	 */
	protected void sequence_ConstRef(EObject context, ConstRefExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (ids+=ID ids+=ID*)
	 */
	protected void sequence_ElementRef(EObject context, ElementRefExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     value=BIG_INT
	 */
	protected void sequence_IntegerLiteral(EObject context, IntegerLiteral semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, InputConstraintPackage.Literals.INTEGER_LITERAL__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, InputConstraintPackage.Literals.INTEGER_LITERAL__VALUE));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getIntegerLiteralAccess().getValueBIG_INTParserRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (leftClosed?='['? left=Scalar? right=Scalar? rightClosed?=']'?)
	 */
	protected void sequence_Interval(EObject context, IntervalExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     value=Scalar
	 */
	protected void sequence_Negative(EObject context, NegativeExpression semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, InputConstraintPackage.Literals.NEGATIVE_EXPRESSION__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, InputConstraintPackage.Literals.NEGATIVE_EXPRESSION__VALUE));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getNegativeAccess().getValueScalarParserRuleCall_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     ref=Ref
	 */
	protected void sequence_Pre(EObject context, PreExpression semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, InputConstraintPackage.Literals.PRE_EXPRESSION__REF) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, InputConstraintPackage.Literals.PRE_EXPRESSION__REF));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getPreAccess().getRefRefParserRuleCall_3_0(), semanticObject.getRef());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     set=Set
	 */
	protected void sequence_RandomElement(EObject context, RandomElementExpression semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, InputConstraintPackage.Literals.RANDOM_ELEMENT_EXPRESSION__SET) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, InputConstraintPackage.Literals.RANDOM_ELEMENT_EXPRESSION__SET));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getRandomElementAccess().getSetSetParserRuleCall_1_0(), semanticObject.getSet());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     interval=Interval
	 */
	protected void sequence_RandomInteger(EObject context, RandomIntegerExpression semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, InputConstraintPackage.Literals.RANDOM_INTEGER_EXPRESSION__INTERVAL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, InputConstraintPackage.Literals.RANDOM_INTEGER_EXPRESSION__INTERVAL));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getRandomIntegerAccess().getIntervalIntervalParserRuleCall_1_0(), semanticObject.getInterval());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     interval=Interval
	 */
	protected void sequence_RandomReal(EObject context, RandomRealExpression semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, InputConstraintPackage.Literals.RANDOM_REAL_EXPRESSION__INTERVAL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, InputConstraintPackage.Literals.RANDOM_REAL_EXPRESSION__INTERVAL));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getRandomRealAccess().getIntervalIntervalParserRuleCall_1_0(), semanticObject.getInterval());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     value=BIGDECIMAL
	 */
	protected void sequence_RealLiteral(EObject context, RealLiteral semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, InputConstraintPackage.Literals.REAL_LITERAL__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, InputConstraintPackage.Literals.REAL_LITERAL__VALUE));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getRealLiteralAccess().getValueBIGDECIMALTerminalRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (members+=Scalar members+=Scalar*)
	 */
	protected void sequence_Set(EObject context, SetExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
}
