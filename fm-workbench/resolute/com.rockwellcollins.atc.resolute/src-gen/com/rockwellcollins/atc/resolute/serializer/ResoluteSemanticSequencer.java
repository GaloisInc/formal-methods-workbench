/*
 * generated by Xtext
 */
package com.rockwellcollins.atc.resolute.serializer;

import com.google.inject.Inject;
import com.google.inject.Provider;
import com.rockwellcollins.atc.resolute.resolute.Arg;
import com.rockwellcollins.atc.resolute.resolute.BaseType;
import com.rockwellcollins.atc.resolute.resolute.BinaryExpr;
import com.rockwellcollins.atc.resolute.resolute.BoolExpr;
import com.rockwellcollins.atc.resolute.resolute.BuiltInFnCallExpr;
import com.rockwellcollins.atc.resolute.resolute.CastExpr;
import com.rockwellcollins.atc.resolute.resolute.ClaimArg;
import com.rockwellcollins.atc.resolute.resolute.ClaimBody;
import com.rockwellcollins.atc.resolute.resolute.ClaimString;
import com.rockwellcollins.atc.resolute.resolute.ConstantDefinition;
import com.rockwellcollins.atc.resolute.resolute.FailExpr;
import com.rockwellcollins.atc.resolute.resolute.FilterMapExpr;
import com.rockwellcollins.atc.resolute.resolute.FnCallExpr;
import com.rockwellcollins.atc.resolute.resolute.FunctionBody;
import com.rockwellcollins.atc.resolute.resolute.FunctionDefinition;
import com.rockwellcollins.atc.resolute.resolute.IdExpr;
import com.rockwellcollins.atc.resolute.resolute.IfThenElseExpr;
import com.rockwellcollins.atc.resolute.resolute.InstanceOfExpr;
import com.rockwellcollins.atc.resolute.resolute.IntExpr;
import com.rockwellcollins.atc.resolute.resolute.LetBinding;
import com.rockwellcollins.atc.resolute.resolute.LetExpr;
import com.rockwellcollins.atc.resolute.resolute.NestedDotID;
import com.rockwellcollins.atc.resolute.resolute.ProveStatement;
import com.rockwellcollins.atc.resolute.resolute.QuantArg;
import com.rockwellcollins.atc.resolute.resolute.QuantifiedExpr;
import com.rockwellcollins.atc.resolute.resolute.RealExpr;
import com.rockwellcollins.atc.resolute.resolute.ResoluteLibrary;
import com.rockwellcollins.atc.resolute.resolute.ResolutePackage;
import com.rockwellcollins.atc.resolute.resolute.ResoluteSubclause;
import com.rockwellcollins.atc.resolute.resolute.SetExpr;
import com.rockwellcollins.atc.resolute.resolute.SetType;
import com.rockwellcollins.atc.resolute.resolute.StringExpr;
import com.rockwellcollins.atc.resolute.resolute.ThisExpr;
import com.rockwellcollins.atc.resolute.resolute.UnaryExpr;
import com.rockwellcollins.atc.resolute.services.ResoluteGrammarAccess;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtext.serializer.acceptor.ISemanticSequenceAcceptor;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.diagnostic.ISemanticSequencerDiagnosticProvider;
import org.eclipse.xtext.serializer.diagnostic.ISerializationDiagnostic.Acceptor;
import org.eclipse.xtext.serializer.sequencer.GenericSequencer;
import org.eclipse.xtext.serializer.sequencer.ISemanticNodeProvider.INodesForEObjectProvider;
import org.eclipse.xtext.serializer.sequencer.ISemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.osate.aadl2.Aadl2Package;
import org.osate.aadl2.ArrayRange;
import org.osate.aadl2.BasicPropertyAssociation;
import org.osate.aadl2.BooleanLiteral;
import org.osate.aadl2.ClassifierValue;
import org.osate.aadl2.ComputedValue;
import org.osate.aadl2.ContainedNamedElement;
import org.osate.aadl2.ContainmentPathElement;
import org.osate.aadl2.IntegerLiteral;
import org.osate.aadl2.ListValue;
import org.osate.aadl2.ModalPropertyValue;
import org.osate.aadl2.NamedValue;
import org.osate.aadl2.Operation;
import org.osate.aadl2.PropertyAssociation;
import org.osate.aadl2.RangeValue;
import org.osate.aadl2.RealLiteral;
import org.osate.aadl2.RecordValue;
import org.osate.aadl2.ReferenceValue;
import org.osate.aadl2.StringLiteral;
import org.osate.xtext.aadl2.properties.serializer.PropertiesSemanticSequencer;

@SuppressWarnings("all")
public class ResoluteSemanticSequencer extends PropertiesSemanticSequencer {

	@Inject
	private ResoluteGrammarAccess grammarAccess;
	
	@Override
	public void createSequence(EObject context, EObject semanticObject) {
		if(semanticObject.eClass().getEPackage() == Aadl2Package.eINSTANCE) switch(semanticObject.eClass().getClassifierID()) {
			case Aadl2Package.ARRAY_RANGE:
				sequence_ArrayRange(context, (ArrayRange) semanticObject); 
				return; 
			case Aadl2Package.BASIC_PROPERTY_ASSOCIATION:
				sequence_FieldPropertyAssociation(context, (BasicPropertyAssociation) semanticObject); 
				return; 
			case Aadl2Package.BOOLEAN_LITERAL:
				sequence_BooleanLiteral(context, (BooleanLiteral) semanticObject); 
				return; 
			case Aadl2Package.CLASSIFIER_VALUE:
				sequence_ComponentClassifierTerm(context, (ClassifierValue) semanticObject); 
				return; 
			case Aadl2Package.COMPUTED_VALUE:
				sequence_ComputedTerm(context, (ComputedValue) semanticObject); 
				return; 
			case Aadl2Package.CONTAINED_NAMED_ELEMENT:
				sequence_ContainmentPath(context, (ContainedNamedElement) semanticObject); 
				return; 
			case Aadl2Package.CONTAINMENT_PATH_ELEMENT:
				sequence_ContainmentPathElement(context, (ContainmentPathElement) semanticObject); 
				return; 
			case Aadl2Package.INTEGER_LITERAL:
				sequence_IntegerTerm(context, (IntegerLiteral) semanticObject); 
				return; 
			case Aadl2Package.LIST_VALUE:
				sequence_ListTerm(context, (ListValue) semanticObject); 
				return; 
			case Aadl2Package.MODAL_PROPERTY_VALUE:
				if(context == grammarAccess.getModalPropertyValueRule()) {
					sequence_ModalPropertyValue(context, (ModalPropertyValue) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getOptionalModalPropertyValueRule()) {
					sequence_OptionalModalPropertyValue(context, (ModalPropertyValue) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getPropertyValueRule()) {
					sequence_PropertyValue(context, (ModalPropertyValue) semanticObject); 
					return; 
				}
				else break;
			case Aadl2Package.NAMED_VALUE:
				if(context == grammarAccess.getConstantValueRule() ||
				   context == grammarAccess.getNumAltRule()) {
					sequence_ConstantValue(context, (NamedValue) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getLiteralorReferenceTermRule() ||
				   context == grammarAccess.getPropertyExpressionRule()) {
					sequence_LiteralorReferenceTerm(context, (NamedValue) semanticObject); 
					return; 
				}
				else break;
			case Aadl2Package.OPERATION:
				sequence_SignedConstant(context, (Operation) semanticObject); 
				return; 
			case Aadl2Package.PROPERTY_ASSOCIATION:
				if(context == grammarAccess.getBasicPropertyAssociationRule()) {
					sequence_BasicPropertyAssociation(context, (PropertyAssociation) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getContainedPropertyAssociationRule() ||
				   context == grammarAccess.getPModelRule()) {
					sequence_ContainedPropertyAssociation(context, (PropertyAssociation) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getPropertyAssociationRule()) {
					sequence_PropertyAssociation(context, (PropertyAssociation) semanticObject); 
					return; 
				}
				else break;
			case Aadl2Package.RANGE_VALUE:
				sequence_NumericRangeTerm(context, (RangeValue) semanticObject); 
				return; 
			case Aadl2Package.REAL_LITERAL:
				sequence_RealTerm(context, (RealLiteral) semanticObject); 
				return; 
			case Aadl2Package.RECORD_VALUE:
				if(context == grammarAccess.getOldRecordTermRule()) {
					sequence_OldRecordTerm(context, (RecordValue) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getPropertyExpressionRule() ||
				   context == grammarAccess.getRecordTermRule()) {
					sequence_RecordTerm(context, (RecordValue) semanticObject); 
					return; 
				}
				else break;
			case Aadl2Package.REFERENCE_VALUE:
				sequence_ReferenceTerm(context, (ReferenceValue) semanticObject); 
				return; 
			case Aadl2Package.STRING_LITERAL:
				sequence_StringTerm(context, (StringLiteral) semanticObject); 
				return; 
			}
		else if(semanticObject.eClass().getEPackage() == ResolutePackage.eINSTANCE) switch(semanticObject.eClass().getClassifierID()) {
			case ResolutePackage.ARG:
				sequence_Arg(context, (Arg) semanticObject); 
				return; 
			case ResolutePackage.BASE_TYPE:
				if(context == grammarAccess.getBaseTypeRule()) {
					sequence_BaseType(context, (BaseType) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getTypeRule()) {
					sequence_BaseType_Type(context, (BaseType) semanticObject); 
					return; 
				}
				else break;
			case ResolutePackage.BINARY_EXPR:
				sequence_AndExpr_ImpliesExpr_OrExpr_PlusExpr_RelationalExpr_TimesExpr(context, (BinaryExpr) semanticObject); 
				return; 
			case ResolutePackage.BOOL_EXPR:
				sequence_AtomicExpr(context, (BoolExpr) semanticObject); 
				return; 
			case ResolutePackage.BUILT_IN_FN_CALL_EXPR:
				sequence_AtomicExpr(context, (BuiltInFnCallExpr) semanticObject); 
				return; 
			case ResolutePackage.CAST_EXPR:
				sequence_PrefixExpr(context, (CastExpr) semanticObject); 
				return; 
			case ResolutePackage.CLAIM_ARG:
				sequence_ClaimText(context, (ClaimArg) semanticObject); 
				return; 
			case ResolutePackage.CLAIM_BODY:
				sequence_DefinitionBody(context, (ClaimBody) semanticObject); 
				return; 
			case ResolutePackage.CLAIM_STRING:
				sequence_ClaimText(context, (ClaimString) semanticObject); 
				return; 
			case ResolutePackage.CONSTANT_DEFINITION:
				sequence_ConstantDefinition(context, (ConstantDefinition) semanticObject); 
				return; 
			case ResolutePackage.FAIL_EXPR:
				sequence_AtomicExpr(context, (FailExpr) semanticObject); 
				return; 
			case ResolutePackage.FILTER_MAP_EXPR:
				sequence_AtomicExpr(context, (FilterMapExpr) semanticObject); 
				return; 
			case ResolutePackage.FN_CALL_EXPR:
				sequence_AtomicExpr(context, (FnCallExpr) semanticObject); 
				return; 
			case ResolutePackage.FUNCTION_BODY:
				sequence_DefinitionBody(context, (FunctionBody) semanticObject); 
				return; 
			case ResolutePackage.FUNCTION_DEFINITION:
				sequence_FunctionDefinition(context, (FunctionDefinition) semanticObject); 
				return; 
			case ResolutePackage.ID_EXPR:
				sequence_AtomicExpr(context, (IdExpr) semanticObject); 
				return; 
			case ResolutePackage.IF_THEN_ELSE_EXPR:
				sequence_AtomicExpr(context, (IfThenElseExpr) semanticObject); 
				return; 
			case ResolutePackage.INSTANCE_OF_EXPR:
				sequence_InstanceOfExpr(context, (InstanceOfExpr) semanticObject); 
				return; 
			case ResolutePackage.INT_EXPR:
				sequence_AtomicExpr(context, (IntExpr) semanticObject); 
				return; 
			case ResolutePackage.LET_BINDING:
				sequence_LetBinding(context, (LetBinding) semanticObject); 
				return; 
			case ResolutePackage.LET_EXPR:
				sequence_AtomicExpr(context, (LetExpr) semanticObject); 
				return; 
			case ResolutePackage.NESTED_DOT_ID:
				sequence_NestedDotID(context, (NestedDotID) semanticObject); 
				return; 
			case ResolutePackage.PROVE_STATEMENT:
				sequence_ProveStatement(context, (ProveStatement) semanticObject); 
				return; 
			case ResolutePackage.QUANT_ARG:
				sequence_Arg(context, (QuantArg) semanticObject); 
				return; 
			case ResolutePackage.QUANTIFIED_EXPR:
				sequence_AtomicExpr(context, (QuantifiedExpr) semanticObject); 
				return; 
			case ResolutePackage.REAL_EXPR:
				sequence_AtomicExpr(context, (RealExpr) semanticObject); 
				return; 
			case ResolutePackage.RESOLUTE_LIBRARY:
				sequence_ResoluteLibrary(context, (ResoluteLibrary) semanticObject); 
				return; 
			case ResolutePackage.RESOLUTE_SUBCLAUSE:
				sequence_ResoluteSubclause(context, (ResoluteSubclause) semanticObject); 
				return; 
			case ResolutePackage.SET_EXPR:
				sequence_AtomicExpr(context, (SetExpr) semanticObject); 
				return; 
			case ResolutePackage.SET_TYPE:
				sequence_Type(context, (SetType) semanticObject); 
				return; 
			case ResolutePackage.STRING_EXPR:
				sequence_AtomicExpr(context, (StringExpr) semanticObject); 
				return; 
			case ResolutePackage.THIS_EXPR:
				sequence_AtomicExpr(context, (ThisExpr) semanticObject); 
				return; 
			case ResolutePackage.UNARY_EXPR:
				sequence_PrefixExpr(context, (UnaryExpr) semanticObject); 
				return; 
			}
		if (errorAcceptor != null) errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Constraint:
	 *     (
	 *         (left=PlusExpr_BinaryExpr_1_0_0_0 (op='+' | op='-') right=TimesExpr) | 
	 *         (left=TimesExpr_BinaryExpr_1_0_0_0 (op='*' | op='/' | op='%') right=PrefixExpr) | 
	 *         (left=RelationalExpr_BinaryExpr_1_0_0_0 op=RelationalOp right=PlusExpr) | 
	 *         (left=AndExpr_BinaryExpr_1_0_0_0 (op='and' | op='andthen') right=InstanceOfExpr) | 
	 *         (left=OrExpr_BinaryExpr_1_0_0_0 op='or' right=AndExpr) | 
	 *         (left=ImpliesExpr_BinaryExpr_1_0_0_0 op='=>' right=ImpliesExpr)
	 *     )
	 */
	protected void sequence_AndExpr_ImpliesExpr_OrExpr_PlusExpr_RelationalExpr_TimesExpr(EObject context, BinaryExpr semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name=ID type=Type)
	 */
	protected void sequence_Arg(EObject context, Arg semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name=ID expr=Expr)
	 */
	protected void sequence_Arg(EObject context, QuantArg semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     val=BooleanLiteral
	 */
	protected void sequence_AtomicExpr(EObject context, BoolExpr semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (fn=BuiltInFn (args+=Expr args+=Expr*)?)
	 */
	protected void sequence_AtomicExpr(EObject context, BuiltInFnCallExpr semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (val=Expr | failmsg+=ClaimText+)
	 */
	protected void sequence_AtomicExpr(EObject context, FailExpr semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (map=AtomicExpr_FilterMapExpr_11_2_0_0 args+=Arg+ filter=Expr?)
	 */
	protected void sequence_AtomicExpr(EObject context, FilterMapExpr semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (fn=[FunctionDefinition|ID] (args+=Expr args+=Expr*)?)
	 */
	protected void sequence_AtomicExpr(EObject context, FnCallExpr semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     id=[NamedElement|QCREF]
	 */
	protected void sequence_AtomicExpr(EObject context, IdExpr semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (cond=Expr then=Expr else=Expr)
	 */
	protected void sequence_AtomicExpr(EObject context, IfThenElseExpr semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     val=IntegerTerm
	 */
	protected void sequence_AtomicExpr(EObject context, IntExpr semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (binding=LetBinding expr=Expr)
	 */
	protected void sequence_AtomicExpr(EObject context, LetExpr semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     ((quant='forall' | quant='exists') args+=Arg+ expr=Expr)
	 */
	protected void sequence_AtomicExpr(EObject context, QuantifiedExpr semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     val=RealTerm
	 */
	protected void sequence_AtomicExpr(EObject context, RealExpr semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     ((exprs+=AtomicExpr_SetExpr_11_2_1_0 exprs+=Expr*) | exprs+=AtomicExpr_SetExpr_11_2_1_0)
	 */
	protected void sequence_AtomicExpr(EObject context, SetExpr semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     val=StringTerm
	 */
	protected void sequence_AtomicExpr(EObject context, StringExpr semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (sub=NestedDotID?)
	 */
	protected void sequence_AtomicExpr(EObject context, ThisExpr semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         type='int' | 
	 *         type='real' | 
	 *         type='string' | 
	 *         type='bool' | 
	 *         type='range' | 
	 *         type='aadl' | 
	 *         type='component' | 
	 *         type='abstract' | 
	 *         type='bus' | 
	 *         type='data' | 
	 *         type='device' | 
	 *         type='memory' | 
	 *         type='processor' | 
	 *         type='process' | 
	 *         type='subprogram_group' | 
	 *         type='subprogram' | 
	 *         type='system' | 
	 *         type='thread_group' | 
	 *         type='thread' | 
	 *         type='virtual_bus' | 
	 *         type='virtual_processor' | 
	 *         type='connection' | 
	 *         type='property' | 
	 *         type='feature' | 
	 *         type='port' | 
	 *         type='data_port' | 
	 *         type='event_port' | 
	 *         type='event_data_port' | 
	 *         type='feature_group' | 
	 *         type='access' | 
	 *         type='bus_access' | 
	 *         type='provides_bus_access' | 
	 *         type='requires_bus_access' | 
	 *         type='data_access' | 
	 *         type='provides_data_access' | 
	 *         type='requires_data_access' | 
	 *         type='subprogram_access' | 
	 *         type='provides_subprogram_access' | 
	 *         type='requires_subprogram_access' | 
	 *         type='subprogram_group_access' | 
	 *         type='provides_subprogram_group_access' | 
	 *         type='requires_subprogram_group_access' | 
	 *         type='flow_specification' | 
	 *         type='end_to_end_flow'
	 *     )
	 */
	protected void sequence_BaseType(EObject context, BaseType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         (
	 *             type='int' | 
	 *             type='real' | 
	 *             type='string' | 
	 *             type='bool' | 
	 *             type='range' | 
	 *             type='aadl' | 
	 *             type='component' | 
	 *             type='abstract' | 
	 *             type='bus' | 
	 *             type='data' | 
	 *             type='device' | 
	 *             type='memory' | 
	 *             type='processor' | 
	 *             type='process' | 
	 *             type='subprogram_group' | 
	 *             type='subprogram' | 
	 *             type='system' | 
	 *             type='thread_group' | 
	 *             type='thread' | 
	 *             type='virtual_bus' | 
	 *             type='virtual_processor' | 
	 *             type='connection' | 
	 *             type='property' | 
	 *             type='feature' | 
	 *             type='port' | 
	 *             type='data_port' | 
	 *             type='event_port' | 
	 *             type='event_data_port' | 
	 *             type='feature_group' | 
	 *             type='access' | 
	 *             type='bus_access' | 
	 *             type='provides_bus_access' | 
	 *             type='requires_bus_access' | 
	 *             type='data_access' | 
	 *             type='provides_data_access' | 
	 *             type='requires_data_access' | 
	 *             type='subprogram_access' | 
	 *             type='provides_subprogram_access' | 
	 *             type='requires_subprogram_access' | 
	 *             type='subprogram_group_access' | 
	 *             type='provides_subprogram_group_access' | 
	 *             type='requires_subprogram_group_access' | 
	 *             type='flow_specification' | 
	 *             type='end_to_end_flow'
	 *         ) 
	 *         paramType=Type?
	 *     )
	 */
	protected void sequence_BaseType_Type(EObject context, BaseType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (arg=[ClaimTextVar|ID] unit=[UnitLiteral|ID]?)
	 */
	protected void sequence_ClaimText(EObject context, ClaimArg semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     str=STRING
	 */
	protected void sequence_ClaimText(EObject context, ClaimString semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name=ID type=Type expr=Expr)
	 */
	protected void sequence_ConstantDefinition(EObject context, ConstantDefinition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (claim+=ClaimText+ expr=Expr)
	 */
	protected void sequence_DefinitionBody(EObject context, ClaimBody semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (type=Type expr=Expr)
	 */
	protected void sequence_DefinitionBody(EObject context, FunctionBody semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name=ID (args+=Arg args+=Arg*)? body=DefinitionBody)
	 */
	protected void sequence_FunctionDefinition(EObject context, FunctionDefinition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (expr=InstanceOfExpr_InstanceOfExpr_1_0_0_0 type=BaseType)
	 */
	protected void sequence_InstanceOfExpr(EObject context, InstanceOfExpr semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (value=UnsignedInt unit=[UnitLiteral|ID]?)
	 */
	protected void sequence_IntegerTerm(EObject context, IntegerLiteral semanticObject) {
		genericSequencer.createSequence(context, (EObject)semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name=ID type=Type expr=Expr)
	 */
	protected void sequence_LetBinding(EObject context, LetBinding semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (base=[NamedElement|ID] sub=NestedDotID?)
	 */
	protected void sequence_NestedDotID(EObject context, NestedDotID semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (type=BaseType expr=PrefixExpr)
	 */
	protected void sequence_PrefixExpr(EObject context, CastExpr semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     ((op='-' | op='not') expr=PrefixExpr)
	 */
	protected void sequence_PrefixExpr(EObject context, UnaryExpr semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     expr=Expr
	 */
	protected void sequence_ProveStatement(EObject context, ProveStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (value=UnsignedReal unit=[UnitLiteral|ID]?)
	 */
	protected void sequence_RealTerm(EObject context, RealLiteral semanticObject) {
		genericSequencer.createSequence(context, (EObject)semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (definitions+=Definition*)
	 */
	protected void sequence_ResoluteLibrary(EObject context, ResoluteLibrary semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (proves+=ProveStatement*)
	 */
	protected void sequence_ResoluteSubclause(EObject context, ResoluteSubclause semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     type=Type
	 */
	protected void sequence_Type(EObject context, SetType semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ResolutePackage.Literals.SET_TYPE__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ResolutePackage.Literals.SET_TYPE__TYPE));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getTypeAccess().getTypeTypeParserRuleCall_0_2_0(), semanticObject.getType());
		feeder.finish();
	}
}
